============================================[01]===========================================

ToDo:

Реализации: 
1) set of char;
2) array .. of boolean;

3)
type tset = record
    x: array of char;
    n: integer;
end;

Базовые операции:
1) Создание пустого множества
2) Проверка существования элемента в множестве
3) Добавление элемента в множество
4) Исключение элемента из множества

Дополнительные операции:
[x] 1) Чтение их файла
[x] 2) Чтение из клавиатуры
[x] 3) вывод
[x] 4) Объединение
[x] 5) Пересечение
 |_[x] Проблема: нужно проверять оба множества.
       Нужно три множества.
[x] 6) Вычитание
[x] 7) (a ∪ b) ∩ (c \ b)
[x] Что-то ломает индекс(где-то выход за границы)
[x] Пофиксить вывод лога
 |_[x] В допоперациях над множествами.

[x] Почему-то возникает ошибка открытия файла на запись.

[x] Если не ввести в командную строку имена файлов, программа крашится, в io
[x] Если нет входных файлов, использует только клавиатуру, ничего не пишет
[-] Ошибка: если ввести больше, чем один символ, программа сломается
 |_[Нет, проблема в самом паскале. Если ввести неверно, лови exeption]
[x] плюс, он создаёт массив на +1

Unnescessary.|
             v
[x] Проблемы с перечислением элементов:
 |  set -- циклический перебор элементов возможен только через
 |         foreach
 |  array of boolean -- ord и crh
 |  array of char -- s[i] можно обращаться и так.
 |_[E] Попробовать для каждого модуля реализовать свой метод получения доступа к элементу. 
       Пусть это будет метод, создающий массив множеств, элементы которого будут 
       подмножества, содержащие 1 элемент. Вот тогда, set of char точно будет 
       индексироваться. Для boolean -- symtoin или intosym. Для char, вроде, никаких хитрых
       манипуляций не нужно.

       Дно, а не план

[x] Проблема с записью файла в main.pas
[?] Порядок действий какой-то проблемный
[x] Беды с getlength
[x] Если мы проверяем обоюдно, то нам getlength не нужен
[x] Не забудь nobool() написать
[x] И intosym()
